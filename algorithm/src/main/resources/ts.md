## 算法可以快速地帮助我们解决问题

比如以下问题:
* 对于一个数组。我们要将其后面几个元素移到前面去，比如 1234567->5671234
要求in place(不允许使用n空间复杂度的算法，只能使用常量辅助空间)
这该怎么做呢？
-------------------------------------
## 分治策略
分治策略,递归地求解一个问题，我们一般要在每层递归中应用以下三个步骤:
* 分解 将问题划分为一些子问题，子问题的形式和原问题一样，只是规模更小
* 解决 递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解
* 合并 将子问题的解组合成原问题的解.

### 例子：归并排序
* 分解：将问题分解为左半边和右半边都为有序排序的子问题。
* 解决：递归地求解子问题的子问题。
* 合并：将子问题：左右合并在一起就为父问题的解.

例子 排序 54236914
* 分为5423 和 6914 为有序排序的这两个子问题
* 然后将5423分为54 和 23两个问题。。
* 54问题足够小了,直接求解->45
* 。。。
* 合并的时候 45和23合并 -> o(n)的复杂度即可完成
* 。。。 
* 2345 和 1469合并 ->12344569

随便讲了下，那么

* 手写一个归并练练手 o(nlogn)
* 手写一个快排 o(nlogn)
* ~~手写一个堆排序~~ o(nlogn)

--------------------------------------------------------


## 动态规划
其实也是把问题分为子问题，但是有时有很多子问题是重复的。。。。不用多次求解

名词：
* 最优子结构： 当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。
* 重叠子问题： 在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。

自顶向下
自底向上

LCS问题 经典

LIS问题
https://leetcode.com/problems/longest-increasing-subsequence/

and so on 

-----------------------------------------------------------

## 番外-贪心算法

有些问题可以用动态规划实现，但是也可能有一些特殊的性质，有更好的算法实现

