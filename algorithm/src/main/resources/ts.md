## 算法可以快速地帮助我们解决问题

比如以下问题:
* 对于一个数组。我们要将其后面3个元素移到前面去，比如 1234567->5671234
要求in place(不允许使用n空间复杂度的算法--比如辅助数组，只能使用常量辅助空间)
这该怎么做呢？
-------------------------------------
## 分治策略
分治策略,递归地求解一个问题，我们一般要在每层递归中应用以下三个步骤:
* 分解 将问题划分为一些子问题，子问题的形式和原问题一样，只是规模更小
* 解决 递归地求解出子问题。如果子问题的规模足够小，则停止递归，直接求解
* 合并 将子问题的解组合成原问题的解.

### 例子：归并排序
* 分解：将问题分解为左半边和右半边都为有序排序的子问题。
* 解决：递归地求解子问题的子问题。
* 合并：将子问题：左右合并在一起就为父问题的解.

例子 排序 54236914
* 分为5423 和 6914 为有序排序的这两个子问题
* 然后将5423分为54 和 23两个问题。。
* 54问题足够小了,直接求解->45
* 。。。
* 合并的时候 45和23合并 -> o(n)的复杂度即可完成
* 。。。 
* 2345 和 1469合并 -> 12344569

随便讲了下，那么

* 手写一个归并练练手 o(nlogn)
* 手写一个快排 o(nlogn)
* ~~手写一个堆排序~~ o(nlogn)

--------------------------------------------------------


## 动态规划
其实也是把问题分为子问题，但是有时有很多子问题是重复的。。。。不用多次求解,动态规划采取将结果存在表里的方法，从而无需重复计算子问题的解
动态规划一般用来求解最优化问题

可用动态规划求解的问题，一般有两个特征
名词：
* 最优子结构： 当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。
* 重叠子问题： 在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。

我们通常按以下步骤来设计一个动态规划算法:
* 刻画一个最优解的结构特征
* 递归地定义最优解的值
* 计算最优解的值，通常采取自底向上的方法
* 利用计算出的信息构造一个最优解

如果仅仅需要一个最优解的值，而非最优解本身，可以忽略第四步

~~自顶而下~~
自底向上

### 钢条切割

某公司购买钢条,将其切割成短钢条出售,切割工序本身没有成本和损耗,公司管理层希望知道最佳的切割方案对应的收益是多少。

长度| 1| 2| 3| 4| 5| 6| 7| 8| 9| 10
------| ------| ------| ------| ------| ------| ------| ------| ------| ------| ------
价格| 1| 5| 8| 9| 10| 17| 17| 20| 24| 30


以上是每段钢条对应的价格.
现在输入一个钢条的长度,求其最大收益:
* 比如长度10,最大收益就是不切割->30.
* 比如长度7,最大收益是17+1=18 或者 5 + 5 + 8 = 18
* 比如长度8,最大收益是17 + 5 = 22

考虑一下,每条钢条的子问题就是选一个切割点,分为两部分。

~~自顶而下~~

自底向上

自底向上少了递归的调用,虽然复杂度一样,但是复杂性函数具有更小的系数

### LIS问题
https://leetcode.com/problems/longest-increasing-subsequence/

### LCS问题 经典
一，问题描述

给定两个字符串，求解这两个字符串的最长公共子序列（Longest Common Sequence）。比如字符串1：BDCABA；字符串2：ABCBDAB

则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA

二，算法求解

* 最优子结构

设 X=(x1,x2,.....xn) 和 Y={y1,y2,.....ym} 是两个序列，将 X 和 Y 的最长公共子序列记为LCS(X,Y)

找出LCS(X,Y)就是一个最优化问题。因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。
* 如果 xn=ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)，LCS(Xn-1，Ym-1)就是原问题的一个子问题。为什么叫子问题？因为它的规模比原问题小。（小一个元素也是小嘛....）。为什么是最优的子问题？因为我们要找的是Xn-1 和 Ym-1 的最长公共子序列啊。。。最长的！！！换句话说，就是最优的那个。（这里的最优就是最长的意思）

* 如果xn != ym，这下要麻烦一点，因为它产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)。
因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长公共子序列中的元素嘛。（都不相等了，怎么公共嘛）。
LCS(Xn-1，Ym)表示：最长公共序列可以在(x1,x2,....x(n-1)) 和 (y1,y2,...yn)中找。
LCS(Xn，Ym-1)表示：最长公共序列可以在(x1,x2,....xn) 和 (y1,y2,...y(n-1))中找。
求解上面两个子问题，得到的公共子序列谁最长，那谁就是 LCS（X,Y）。用数学表示就是：
LCS=max{LCS(Xn-1，Ym)，LCS(Xn，Ym-1)}
由于条件 1)  和  2)  考虑到了所有可能的情况。因此，我们成功地把原问题 转化 成了 三个规模更小的子问题。

and so on 

-----------------------------------------------------------

## 番外-贪心算法
有些问题可以用动态规划实现，但是也可能有一些特殊的性质，有更好的算法实现

贪心算法在每一步都作出当时看起来最佳的选择,就是说总做出局部最优的选择。其并不保证得到最优解,但对许多问题确实可以求得最优解。

比如一个简单而不平凡的问题:活动选择问题

其是一个调度竞争共享资源的多个活动的问题，目标是选出一个最大的互相兼容的活动集合。
假定有一个 n 个活动的集合S=a1,a2,...,an这些活动使用同一个资源（例如一个阶梯教室），
而这个资源在某个时刻只能供一个活动使用。每个活动ai都有一个开始时间si和一个结束时间fi ，
其中0≤si<fi<∞。如果被选中，任务ai发生在半开时间区间[si,fi)期间．
如果两个活动ai和aj满足[si,fi)与[sj,fj)不重叠，则称它们是兼容的．
也就是说，若si≥fj或sj≥fi，则ai和aj是兼容的．在活动选择问题中，
我们希望选出一个最大兼容活动集。假定活动已按结束时间的单调递增顺序排序：
f1≤f2≤f3≤...≤fn−1≤fn

i| 1| 2| 3| 4| 5| 6| 7| 8| 9| 10| 11 
------|------|------|------|------|------|------|------|------|------|------|------
si|1|3|0|5|3|5|6 |8	|8 |2 |12 | --
fi|4|5|6|7|9|9|10|11|12|14|16 | --

对于这个例子，子集S=a3,a9,a11由相互兼容的活动组成。但它不是一个最大集，因为子集S=a1,a4,a8,a11更大。实际上S=a1,a4,a8,a11是一个最大兼容活动子集，另一个最大子集是 
S=a2,a4,a9,a11

最优子结构
假定集合Sij（ai结束之后，aj开始之前的活动）的一个最大相互兼容的活动子集为Aij，而且Aij包含了活动ak。 由于最优解包含了活动ak，我们得到两个子问题：Sik（ak开始之前的活动）的兼容活动 和 Skj（ak结束之后的活动）的兼容活动。由剪切-粘贴法可以证明Sij的最优解为Sik的最优解、ak、 Skj的最优解组成。即Aij=Aik∪ak∪Akj。 
所以这时我们可以用动态规划方法求出所有k的取值情况对应的解，然后找出一个最大的作为最优解。 
如果用c[i,j]表示Sij的最优解的大小，递归式为：
* if Sij=∅，c[i,j] = 0
* if Sij≠∅, c[i,j]=max{c[i,k]+c[k,j]+1}

###贪心选择

 动态规划需要考虑每种子问题，比较之后得出哪种选择是最优解。假如我们无需求解每种子问题，直接就可以找出一个最优选择。那么将大大减少计算过程。对于活动选择问题，我们可以只考虑一个选择：贪心选择。
 
 直观上，我们应该选择一个活动，使得选择它后剩下的资源可以尽可能多的被其他活动利用。直觉告诉我们选择S中最早结束的活动，因为他可以剩下尽可能多的资源。由于我们活动时按照结束时间排序的，也就是说贪心选择就是a1。
 
 当做出贪心选择后，只剩下一个子问题需要求解，因为不会有在a1开始前结束的活动。加上前面的最优子结构性质，所以S的最优解就是a1⋃A1n。
 
 证明贪心选择——最早结束的活动总是最优解的一部分：
 
 定理： 考虑任意非空子问题Sk，另am是Sk中最早结束的活动，则am在Sk的某个最大兼容活动子集中。
 
 证明： Ak是Sk的某个最大兼容活动子集，aj是Ak中最早结束的活动。如果aj=am，则已经证明am在Sk的某个
 最大兼容活动子集中；如果aj≠am，那么用am替换Ak中的aj产生A′k，由于fm≤fj而且Ak中的活动都是不相交的，所以A′k也是Sk的最大兼容活动子集，得证。
 
浅尝辄止

实际应用:赫夫曼编码，最小生成树算法,单源最短路径(迪杰斯特拉算法)
